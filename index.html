<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js笔记/正式课第一天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/02/js笔记/正式课第一天/" class="article-date">
  <time datetime="2017-05-02T09:52:12.094Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##正式课第一天<br>[TOC]</p>
<p>####闭包</p>
<blockquote>
<p>1.函数执行的时候会形成一个私有作用域，来保护里面的私有变量不受外界干扰；<br>   私有作用域是一种机制；</p>
<p>####函数执行的步骤</p>
<ul>
<li>1.形成私有作用域</li>
<li>2.给形参赋值</li>
<li>3.预解释</li>
<li>4.函数体执行<br>####作用域链<br>#####在私有作用域下遇到变量先看是不是自己私有变量（两种var和function），是的话就是私有，不是的话就往上一级找，如果还没有继续找，直到找到全局为止，还是没有就报错了，这种查找机制叫做作用域链，私有作用域下的私有变量外界访问不到，但是可以获取到外界的变量；<br>####查找上一级作用域<br>看当前这个函数对应的堆内存在哪个作用域下定义的，那么他的上一级就是这个作用域，跟在哪里执行没关系；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var num=1;</div><div class="line">function fn()&#123;</div><div class="line">var num=10;</div><div class="line">function ff()&#123;</div><div class="line">console.log(sum)//sum=10，找ff所在的上一级；</div><div class="line">&#125;</div><div class="line">return ff</div><div class="line">&#125;</div><div class="line">var ff=fn();</div><div class="line">console.log(ff());//ff没有return 所以是输出undefined；</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>####内存的销毁机制</p>
<p>#####堆内存：只要这个堆内存没有被任何变量或属性占用它，浏览器就会主动销毁；其他的要手动销毁，（在做项目时候遇到一个对象以后不用了，手动清空一下，obj=null）；</p>
<p>#####栈内存（作用域）：</p>
<blockquote>
<p>全局作用域：关闭浏览器的时候就销毁了，做项目的时候尽量避免全局变量的使用；<br>私有作用域：相同的函数每一次执行都会形成一个私有作用域，作用域之间没有任何关系；那么他是怎么销毁的呢；</p>
<ul>
<li>1.立即销毁 函数没有返回值或者返回值得内容没有被占用，浏览器就会把它销毁了；</li>
<li>2.暂时不销毁：函数返回了一个函数，这个返回的函数接着执行了，完了之后浏览器会抽时间销毁，（什么时候销毁每个浏览器的机制不一样）</li>
<li>3.不销毁：函数执行返回一个地址，这个地址一直被占用着；<br>作用域不销毁这个概念主要是用在给元素绑定事件的时候<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function  fn1()&#123;</div><div class="line">    console.log(&quot;销毁&quot;)</div><div class="line">&#125;</div><div class="line">fn1();//这个函数执行完后对后面没什么影响就销毁了</div><div class="line">var box=document.getElementById(&quot;box&quot;)</div><div class="line">box.onclick=function ()&#123;</div><div class="line">&#125;;//此时不销毁</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>####this</p>
<ul>
<li>执行的主体，谁来执行的</li>
<li>注意上下文；</li>
<li>全局作用域下this就是window<br>#####私有作用域下的this<blockquote>
<p>1.自执行函数中的this永远是window</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function ()&#123;</div><div class="line">   console.log(this)//此时this就是window</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>2.给元素绑定事件的时候给谁绑定的，this就是谁；<br>3.函数执行的时候看前面有没有点，有点的话前面是谁this就是谁，没有点this就是window；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name=&quot;天线宝宝&quot;</div><div class="line">function()&#123;</div><div class="line">  console.log(this.name)//thisz此时代表window；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.函数作为参数的时候this是Windows，比如定时器，数组中sort排序中的函数，</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/02/js笔记/正式课第一天/" data-id="cj27dljaz0002lkvc80aslo2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js笔记/js正式课第三天(周六)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/02/js笔记/js正式课第三天(周六)/" class="article-date">
  <time datetime="2017-05-02T09:52:12.071Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##js正式课第三天(周六)<br>[TOC]</p>
<p>#####自定义属性</p>
<blockquote>
<p>一般都是给某些元素增加一个自己起的属性名（不是内置属性），来存储一些值的；只要是引用数据类型都可以加自定义属性（包括函数）；</p>
<p>#####引用数据类型的赋值过程<br>1 .浏览器先看是什么数据类型，是对象的话浏览器给他开辟一个堆内存；</p>
<ol>
<li>把所有的 键值对（属性名：属性值）放到这个堆内存里，如果属性值时变量放的是变量所代表的值；</li>
<li>把这个地址赋给对象<br>#####函数的赋值过程</li>
<li>浏览器看他是什么数据类型，是函数的话，给他开辟一个堆内存；</li>
<li>将函数作为字符串存起来；</li>
<li>将地址赋给函数名；</li>
<li>如果把函数当参数传进去只写定义部分不执行<br>#####预解释<br>注意：在全局中，声明的时候就相当于给window增加一个属性；<br>不管是全局还是私有的情况，如果代码执行遇到一个变量，这个变量是没有声明过的变量也相当于给window增加一个属性；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1.预解释：声明s=undefined，声明定义function d（）</div><div class="line">console.log(d);//此时输出function d()&#123;console.log(1)&#125;</div><div class="line">d=1;//给d赋值d=1，此时d已经改变不是函数</div><div class="line">var s=d//s=d也就是s=1；</div><div class="line">function d()&#123;</div><div class="line">  console.log(1)</div><div class="line">&#125;</div><div class="line">d()://报错d is not a function;</div><div class="line">var a=1,b=1,c=1;//相当于var了3次</div><div class="line">var a=1;b=1;c=1;//相当于只var了a；</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>#####预解释的特殊情况</p>
<blockquote>
<p>1.预解释的首行遇到变量名相同的情况，变量名已被声明过了不需要重新声明但是需要重新定义，一般注意var的变量名和function变量名相同的情况；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; s=s()//s现在是函数，也就地址</div><div class="line">&gt; var s=0//此时s已赋值s=0</div><div class="line">&gt; function  s()&#123;</div><div class="line">&gt;    return s //返回函数身</div><div class="line">&gt;  &#125;</div><div class="line">&gt;  s();//此时s已不是函数报错</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>2.等号右边的不预解释<br>3.return出来的内容执行但不预解释，return后面的内容不执行但预解释；<br>4.自执行函数不进行预解释；<br>5.函数作为参数的时候也不进行预解释；<br>6.条件中，不管条件是否成立{}里面的代码都会预解释，但是要注意function只声明不定义，如果遇到变量名相同会报错；如果条件成立先给函数赋值在执行代码；<br>变量只声明就是undefined如var a=1声名后a=undefined，赋值后才是a=1；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;if(&quot;a&quot;in window)&#123;</div><div class="line">&gt;    var a=1;//此时就会报错&apos;a&apos; has already been decleared (a 已被声明过了)</div><div class="line">&gt;    function a()&#123; </div><div class="line">&gt;    &#125;</div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####内存（两种）</p>
<blockquote>
<p>堆内存：来存储东西的，一般存储引用数据类型；<br>栈内存：代码执行空间，也就是作用域：</p>
<ul>
<li>作用域（两种）：</li>
<li>全局作用域：一打开浏览器就会形成；</li>
<li>私有作用域：函数执行形成的作用域；</li>
</ul>
<p>函数执行的时候：<br>1.函数一执行，形成一个私有作用域<br>2.有形参的换先给形参赋值；<br>3.预解释；<br>4.代码执行；</p>
<p>#####私有变量（两种）记住只能自己使用别人获取不到也就是闭包机制；<br>1.形参；<br>2.在私有作用域声名过的变量，var过的和function过的；</p>
<p>#####查找上一级作用域<br>看当前作用域对应的堆内存是在哪个作用域下定义的，那个作用域就是他的上一级；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var d=1</div><div class="line">function F1()&#123;</div><div class="line">  var d=0</div><div class="line">  function f1()&#123;</div><div class="line">  d++</div><div class="line">  console.log(d)</div><div class="line">&#125;</div><div class="line">return f1</div><div class="line">&#125;</div><div class="line">var f1=F1();</div><div class="line">console.log (f1());//f1的上一级作用域就是F1；</div></pre></td></tr></table></figure></p>
<p>当遇到变量的时候，先看是不是自己的私有变量，如果是就是私有的，不是往上一级作用域去找，没有继续找。一直找到全局下在没有就报错了；</p>
<p>#####return 后面函数预解释问题<br>return出来的内容不进行预解释，但是如果return出来的是一个有名函数，在这个函数执行的时候，先预解释这个函数名，而且还是私有的；</p>
<p>#####内存的销毁机制<br>由于函数的定义或者执行会形成堆内存和栈内存，浏览器会找机会清除一些没有被占用的内存。<br>主要来看我们的栈内存（作用域）：<br>全局作用域：浏览器关闭就会销毁；<br>私有作用域：<br>1.函数执行完对其他东西没有影响和关系，那他就销毁。<br>2.如果一个函数执行后返回一个引用数据类型（函数，对象）被外界占用了，那么他就符合不销毁的条件；（比如给一个元素绑定事件的时候；）<br>3.如果一个函数执行完返回一个函数，之后立马执行，前一个函数暂时不销毁后面执行完之后浏览器才会抽时间销毁；<br>对于不销毁的作用域，它里面的私有变量就不行销毁；所以我们可以利用这个特点来存储一些我们想要的值，比如选项卡中存储索引；</p>
<p>#####this<br>1.函数执行的时候看前面有没有点，没有就是window，有点前面就是this；<br>2.自执行函数也是Window；<br>3.函数作为参数的是this也是window；<br>4.元素绑定事件，给谁绑定的谁就是this；</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/02/js笔记/js正式课第三天(周六)/" data-id="cj27dljan0000lkvc8ztxti3e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js笔记/js正式课第二周第一天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/02/js笔记/js正式课第二周第一天/" class="article-date">
  <time datetime="2017-05-02T09:52:12.048Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##js正式课第二周第一天</p>
<p>[TOC]</p>
<p>####title:DOM</p>
<p>#####for in循环</p>
<blockquote>
<p>for in循环在遍历的时候默认的话把自己私有的和在他所有类原型是扩展的属性和方法都可以遍历到，但是一般情况下我们只需要遍历私有的即可，我们可使用一下方法的判断处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var key in obj)&#123;</div><div class="line">   if(obj.propertyEnumerable(key))&#123;console.log(key)&#125;</div><div class="line"> 或者</div><div class="line"> if(obj.hasOwnProperty(key))&#123;</div><div class="line"> console.log(key)&#125;//常用</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以以后用for in的时候要写用于值遍历私有的可枚举的；</p>
<p>#####Object.create(proObj) 创建一个新的对象，但还要把proObj作为这个对象的原型；（IE6-8不兼容）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;s:2&#125;</div><div class="line">var obj2=Object.create(obj)</div><div class="line">//等于把obj作为了obj2的原型；</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####call方法（低版本IE不支持）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(Function.prototype.call.length)</div><div class="line">函数原型上的call方法是一个函数，这个方法至少要传一个参数，这个参数是用来改变call前面的方法的this的；</div></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>call的两个作用：1，改变this；2，让当前函数执行；<br>非严格模式；<br>fn.call(obj):1,将fn中的this变成obj。2.让fn执行；<br>在非严格模式下，不传参数或者传了null，undefined，默认this就window;<br>call方法从第二个参数开始就是给前面的函数传的参数；fn.call(obj,1,2);<br>2.当使用函数.call.call(),两个及连个以上的call，最后一个call的第一个参数是用来改变前面call方法的this的，那么this（）就变成了第一个参数执行，所以第一个参数必须是函数否则会报错；<br>call:记住三句话1.改变前面方法的this，不管前面有多少东西；2. 让前面方法执行，不管前面有多长；  3. call方法最终执行的核心是this（）；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;console.log(this)&#125;;</div><div class="line">fn();</div><div class="line">fn.call.call(obj)//报错obj is not a function;</div><div class="line">所两call及以上要传函数；</div></pre></td></tr></table></figure>
</li>
</ol>
<p>“use strict”严格模式：<br>1.执行函数的时候，前面没有点，this就是undefined；<br>2.不传参数或者传了undefined或null，this就等于null或undefined；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">&quot;use strict&quot;//严格模式</div><div class="line">function fn()&#123;console.log(this)&#125;;</div><div class="line">fn();</div><div class="line">fn.call()//this=undefined;</div><div class="line">fn.call(undefined)//this=undefined;</div><div class="line">fn.call(null)//this=null</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####length:</p>
<blockquote>
<p>所有的函数都有一个属性叫length，表示的是参数的数量（长度）；</p>
<p>#####try{}catch(e) 浏览器隐藏自己的错误;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">//先执行try里面的代码，如果报错了就执行catch里面的代码；</div><div class="line">&#125;catch(e)&#123;</div><div class="line">//e是一个对象，里面存着错误信息，存在e.message,这里面存着try里面的错误信息</div><div class="line">     //throw new Error（&quot;我错了&quot;）</div><div class="line">  &#125;</div><div class="line"> //call将类数组转为数组；</div><div class="line">    function toArray(likeArray) &#123;</div><div class="line">        //call在低版本IE下不支持</div><div class="line">        var ary = [];</div><div class="line">        try &#123;</div><div class="line">            //return ary.__proto__.slice.call(likeArray)</div><div class="line">            return Array.prototype.slice.call(likeArray, 0);</div><div class="line">        &#125;</div><div class="line">        catch (e) &#123;</div><div class="line">            console.log(e.message);</div><div class="line">            for (var i = 0; i &lt; likeArray.length; i++) &#123;</div><div class="line">                ary.push(likeArray[i])</div><div class="line">            &#125;</div><div class="line">            return ary</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    function fn() &#123;return toArray(arguments)&#125;</div><div class="line">    console.log(fn(1, 2, 3, 5, 6, 7, 10));</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####apply;(Function.prototype.apply)</p>
<blockquote>
<p>apply 跟call意思和用法一样，区别是：apply的一个参数也是改变this用的，第二个参数是一个数组，这个数组是给前面的方法传参数的，将数组里面的每一项一个一个传给函数；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 非严格模式</div><div class="line"> function fn(x,y) &#123;</div><div class="line">        this.x=x+y;</div><div class="line">        this.y=x-y;</div><div class="line">        console.log(this.x,this.y,x,y)</div><div class="line">    &#125;</div><div class="line">    fn(1,2);//this-&gt;window</div><div class="line">    fn.call(null,1,2);//this-&gt;null</div><div class="line">    var ary=[1,2];</div><div class="line">    fn.apply(undefined,ary)；//this-&gt;undefined</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####bind(低版本IE不兼容)</p>
<blockquote>
<p>bind只改变函数中的this，返回一个新的函数，原来的函数不变，不让函数执行bind以后再事件中常用我们会写一个兼容模式；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a=2</div><div class="line">function fn()&#123;</div><div class="line">  console.log(this.a)</div><div class="line">&#125;</div><div class="line">var obj=&#123;a:1&#125;</div><div class="line">fn()//this是window；输出2</div><div class="line">fn.bind(obj)//没有()不执行执行的话要手动执行;如果执行输出1；</div><div class="line">//bind 执行过程=克隆了一个新函数,和var fn1=fn.bind(obj)一样函数里面的this变成obj；</div><div class="line">//如果要执行也可以写成fn1();</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####数据类型检测</p>
<p>######typeOf</p>
<blockquote>
<p>能够详细检测基本数据类型，返回值是一个字符串，如果两及两个以上的typeOf检测的话返回值是“string”，但是null检测出来是object，对于引用数据类型不能详细检测只有object和function；</p>
<p>######instanceOf<br>检测一个实例是否属于某个类，因为每一种数据类型都对应自己所属的类，所以我们可以通过他来检测数据类型，但是有局限性，对于基本数据类型 用字面量创建方式创建出来的变量检测不出来，构造函数方式可以，引用数据类型可以详细检测；</p>
<p>######类原型上的constructor；<br>每个类原型（prototype）上都有一个constructor属性，他指向类本省，那么一个具体的数据类型的实例.constructor; 比如:’11’.constructor-&gt;’11’.<strong>proto</strong> -&gt;string.prototype,string原型上有constructor指向string本身，你也可以通过他的neme来得到string类名，也就是他的数据类型</p>
<p>#####对象的Object类的原型上有一个toString方法:<br>他可以检测数据类型，那么我们就调用Object.prototype.toString()这个方法，用call方法将里面的this改变成我们想检测的那个数据，会得到[object   数据类型]；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//toString</div><div class="line"> console.dir(Object.prototype);</div><div class="line"> console.log((&#123;1: 1&#125;).toString());</div><div class="line"> var str=&quot;11&quot;;</div><div class="line"> var number=1;</div><div class="line"> var ary=[1];</div><div class="line"> var time=new Date();</div><div class="line"> console.log(Object.prototype.toString.call(str));</div><div class="line"> console.log(Object.prototype.toString.call(number));</div><div class="line"> console.log(Object.prototype.toString.call(ary));</div><div class="line"> console.log(Object.prototype.toString.call(time));</div><div class="line"> var s=Object.prototype.toString.call(time);</div><div class="line"> console.log(typeof s);</div><div class="line"> //&apos;[object Date]&apos;</div><div class="line"> //console.log(s.split(&quot; &quot;)[1].replace(&quot;]&quot;,&quot;&quot;));</div><div class="line"> console.log(s.substring(8, s.length - 1),s);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>####JSON（是一个格式）；</p>
<blockquote>
<p>1.JSON是个对象，是window下的一个属性，也可以理解为是一个全局变量，在低版本的IE下没有；<br>JNOS和普通对象的区别：<br>1.对象的属性名用双引号包起来；<br>2.属性值如果是字符串的话也得用双引号包起来；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> var jsonObj=&#123;&quot;a&quot;:&quot;a&quot;,&quot;1&quot;:1,&quot;age&quot;=12&#125;</div><div class="line"> //json字符串，一般从后台获取回来的数据都是json字符串；</div><div class="line"> var jsonStr=&apos;&#123;&quot;a&quot;:&quot;a&quot;,&quot;1&quot;:1,&quot;age&quot;=12&#125;&apos;;</div><div class="line"> //JSON.parse()将JSON格式的字符串转为JSON格式的对象；</div><div class="line"> JSON.parse(jsonStr);</div><div class="line">  //JSON.stringfy()将JSON格式的对象转为JSON格式的字符串；</div><div class="line"> JSON.stringfy(jsonStr);</div><div class="line"> </div><div class="line">//在IE没有JSON就用eval来实现；</div><div class="line">function jsonParse(jsonStr)&#123;</div><div class="line">  //如果有就用JSON.parse;</div><div class="line">  try&#123;return JSON.parse(jsonStr)&#125;</div><div class="line">  //如果没有就用eval；</div><div class="line">  catch(e)&#123;renturn eval(&quot;(&quot;+jsonSrr+&quot;)&quot;)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function jsonParse(jsonStr)&#123;</div><div class="line"> return &quot;JSON&quot; in window</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####DOM映射；</p>
<blockquote>
<p>通过DOM获取的元素集合（类数组），仍然和页面的元素保持着联系，并且这个元素集合会随着页面元素的增加而增加，减少而减少；即使将这个结合（类数组）转为一个数组之后，每个元素仍然和页面有联系这就叫做DOM映射；</p>
<p>#####回流<br>值元素的位置发生改变（比如增加元素，删除元素，移动）就会引起回流，让整个页面重新加载一遍，从而造成性能的浪费；</p>
<p>#####重绘<br>元素的样式改变就会把当前的这个元素重新渲染一遍；所以在以后的项目中，能用重绘代替就不用回流，能用一次回流就不要使用多次；</p>
</blockquote>
<p>#####向页面增加元素的方式：</p>
<blockquote>
<p>1.动态创建的方式: document.createElement, 然后一个一个appendChild, 会造成多次回流，这样不好，但是他有个好处就是不会改变原来的元素（比如不会影响他之前绑定的事件）<br>2.通过拼接字符串，最后在一次性通过innerHTML ,这样只引起一次回流，比较好，但是他会改变原来的元素（比如会影响他之前绑定的事件）；<br>3.文档碎片，他就是一个容器专门来盛放DOM元素的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var flg=document.createDocumentFragement();//文档碎片；</div><div class="line">    flg=null//用完后就清空；</div></pre></td></tr></table></figure></p>
<p>文档碎片步骤<br>1.先创建元素,var oli=document.createElement(“li”);<br>2.按需求给元素增加一些需要的属性；<br>3暂时存放在flg（DOM碎片）中，也就是appendChild进去的；<br>4.循环完之后，把整个flg放到ul中，news.appendChild(flg):这样就只回流一次；（news是ul的id）；</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/02/js笔记/js正式课第二周第一天/" data-id="cj27dljax0001lkvcnm93u91u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js笔记/js正式课第二天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/02/js笔记/js正式课第二天/" class="article-date">
  <time datetime="2017-05-02T09:52:12.024Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#js正式课第二天<br> [TOC]</p>
<p>#####面向对象</p>
<blockquote>
<p>面向对象开发也是面向类的开发；<br>【内置类】：<br> 每一种数据类型都有自己所属的类：Number,String,Boolean,Null Undefined ,Object,  Array,Date,RegExp,Function(注意：Math不是类)；<br> 每一个元素也有自己的类<br> 【注意】：Object是所有类的基类，js中万物接对象，而且所有的类都是函数；<br> 【自定义类】：函数</p>
<p>####在js中我们大体分为两种一种是【内置类】，一种是【自定义类】；</p>
<p>#####【内置类】<br>每一个数据类型都是一个类，Number，String，Boolean，Null，Array，Object，Date，等等。（注意：Math不是一个类）。<br>元素都有自己的内置类；</p>
<p>#####命名空间<br>在之前obj1，obj2就是一个简单的对象名，在这里我们叫命名空间；</p>
<p>#####模块化开发</p>
<p>######单例模式：（就是一个对象保障变量名不冲突）<br>将一个完整的项目分模块，多个人共同开发，每个人分模块写在一个对象里面，就是单例模式；<br>注意：单例模式就是一个对象，单例模式函数之间可以用this互相调用，this就是那个单例模式的对象</p>
<p>######工厂模式：<br>把实现相同功能的方法封装成一个函数，以后再想实现这个功能就不用重写代码了，直接执行函数，通过参数来得到具体的实例；（好处：低耦合高内聚，就是减少页面代码的冗余，提高代码利用率）这种方法不常用；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; var girlFriend0=&#123;name:&quot;刘嘉玲&quot;,age:46&#125;;</div><div class="line">    var girlFriend1=&#123;name:&quot;刘亦菲&quot;,age:36&#125;;</div><div class="line">    var girlFriend2=&#123;name:&quot;刘诗诗&quot;,age:26&#125;;</div><div class="line">    function getObj(name,age) &#123;</div><div class="line">        var obj=&#123;&#125;;</div><div class="line">        obj.name=name;</div><div class="line">        obj.age=age;</div><div class="line">        return obj</div><div class="line">    &#125;</div><div class="line">    console.log(getObj(&quot;秀秀&quot;, 20));</div><div class="line">    console.log(getObj(&quot;赵四&quot;, 40));</div><div class="line">    console.log(getObj(&quot;赵启慧&quot;, 19));</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####函数只有重写没有重载，函数名相同后面的覆盖前面的函数</p>
<blockquote>
<p>重载是根据参数不同去选择性的执行某个函数；</p>
<p>#####构造函数模式：<br>构造一个类，因为类是函数数据类型的，所以我通过写一个函数来表示一个【自定义类】<br>怎么让他表示一个类？<br>1.最好首字母大写；</p>
<ol>
<li>通过new这个关键词来创造一个变量，这个变量叫做实例-&gt;var 实例=new 类；<br>3.通过this 给他的实例增加属性名和属性值；<br>#####new一个类的具体实例的运行步骤<br>1.预解释<br>2.自动生成一个this（代表当前实例），通过this给实例增加属性名，属性值<br>3.默认将创建好的实例this返回，不需要return；（如果写了return：1，return了基本数据类型不受影响。2，return了引用数据类型return啥返回啥；</li>
</ol>
</blockquote>
<p>#####函数（三重身份）（new构造函数创建方式函数名尽量用大写和普通函数区分）（this）</p>
<blockquote>
<p> 1.普通的函数，就代表一个方法</p>
<ol>
<li>它也是一个 类 自定义类</li>
<li>它也是Function类的一个实例</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">var obj1=new Fn（）；</div><div class="line">new就是构造函数的创建方式，Fn函数就是一个类，obj1就是Fn类的一个实例</div><div class="line">Fn（）创建过程：</div><div class="line">1.形成一个私有作用域</div><div class="line">2.预解释</div><div class="line">3.自动创建一个实例this</div><div class="line">4.代码执行的时候通过this给实例增加私有属性，并赋值；</div><div class="line">5.会默认返回当前的这个实例this</div><div class="line">注意：1.通过this给实例增加的是私有属性，每个实例之间的私有属性是私有的不一样的；</div><div class="line">     2.不用写return直接返回this，如果你写了，写的是基本数据类型的没有影响，如果你写的是引用数据类型的就会把this修改了，写的啥返回啥；</div><div class="line">     3.var obj=new Fn();等于var obj=new Fn;Fn后面加不加括号第一样；</div><div class="line"></div><div class="line"></div><div class="line">        function fn() &#123;</div><div class="line">       var obj=&#123;&#125;;</div><div class="line">       obj.name=&quot;aa&quot;;</div><div class="line">       obj.age=12;</div><div class="line">       return obj</div><div class="line">    &#125;</div><div class="line">    var obj=fn();</div><div class="line">    function Fn() &#123;</div><div class="line">        //this-&gt;obj</div><div class="line">        this.name=&quot;aa&quot;;</div><div class="line">        this.age=12;</div><div class="line">        this.f=function () &#123;</div><div class="line">            console.log(&quot;11&quot;)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    var obj1=new Fn();</div><div class="line">    //obj1是Fn这个类的一个具体的实例</div><div class="line">    var obj2=new Fn();</div><div class="line">    //obj2是Fn这个类的一个具体的实例</div><div class="line">    console.log(obj1.f===obj2.f);</div><div class="line"></div><div class="line">    console.log(obj1);</div><div class="line"></div><div class="line">    function FF() &#123;</div><div class="line">        //this-&gt;obj</div><div class="line">        this.name=&quot;aa&quot;;</div><div class="line">        this.age=12;</div><div class="line">        this.f=function () &#123;</div><div class="line">            console.log(&quot;11&quot;)</div><div class="line">        &#125;</div><div class="line">        return this</div><div class="line">    &#125;</div><div class="line">    var obj0=new  FF();</div><div class="line">    console.log(obj0);</div><div class="line"></div><div class="line">    var num=1;</div><div class="line">    function XX() &#123;</div><div class="line">        var num=12;</div><div class="line">        this.num=10;</div><div class="line">        this.x=100;</div><div class="line">        this.y=function () &#123;</div><div class="line">            console.log(this.x+num)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var x1=new XX();</div><div class="line">    console.log(x1.x,x1.num);</div><div class="line">    //x1.x=100,x1.num=10</div><div class="line">    x1.y();</div><div class="line">    var x2=new XX();</div><div class="line">    //x2=&#123;num:10,x:100,y:function()&#123;&#125;&#125;</div><div class="line">    console.log(x1.x===x2.x);</div><div class="line">    console.log(x1.y===x2.y);//false</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!--</div><div class="line">var x1=new XX();</div><div class="line">创建了XX类的一个实例x1,</div><div class="line">先让XX执行，形成一个私有作用域，预解释：var 私有变量num</div><div class="line">私有作用域中代码执行：num=12；</div><div class="line">通过this给实例增加了三个私有属性，并且赋值，然后将创建的好的this实例返回出来给了x1,现在x1=&#123;num:10,x:100,y:function()&#123;&#125;&#125;</div><div class="line">x1.y()-&gt;function () &#123;</div><div class="line">console.log(this.x+num)&#125;</div><div class="line">这里面的this值得是x1,x1.x+12=112</div><div class="line">--&gt;</div></pre></td></tr></table></figure>
<p>#####所有的类都是函数数据类型，Object是一个类，说明Object是函数数据类型的。他就是函数数据类型的一个实例；</p>
<p>#####原型模式</p>
<blockquote>
<p>实例通过this得到的是私有的属性和方法，还可以继承所属类的共有属性和方法，比如说，每个数组都有sort这个方法，这个方法是在类Array原型上，因为所有数组都是Array类的一个具体实例，所以只要是数组就可以用；<br>1.每一个函数数据类型（函数，所有的类）天生都有一个prototype（原型）属性；prototype里面存储的是共有的属性和方法，这个属性是一个对象数据类型的，浏览器会给他开辟一个堆内存，开辟的堆内存里边又有一个天生自带的属性construction（构造函数），而且指向的是类本身；<br>2.所有的对象数据类型都有一个（数据类型中除了函数和基本数据类型的其他都是,注意：实例和prototype是对象数据类型）天生自带–proto–，指向所属类的原型（prototype）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function FF()&#123;</div><div class="line">   //this </div><div class="line">   this.a=12</div><div class="line">   this.ff=function&#123;</div><div class="line">   cosole.log thsi.(a)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####链试写法的实现的原理   return this</p>
<p>#####原型的链：</p>
<blockquote>
<p>实例.属性名，遇到属性名先看是不是自己的私有属性，如果是的话就用私有的，不是的话，通过实例的_ <em>proto</em> <em>找到所属类的原型（prototype），还没有的话，通过所属类的prototype的</em> <em>proto</em> _继续找，一直找到基类Objcet的prototype,在没有就是undefined；</p>
<p>#####object 是js中所有对象数据类型的基类（最顶层的类）；<br>1.在Object.prototype上没有<strong>proto</strong>这个属性，是一个唯一没有这个属性的</p>
<p>#####原型链模式<br>f1.hasOwnProperty(“x”);//true可以输出说明hasOwnProperty是f1的一个属性；但是我们发现f的私有属性上并没有这个方法，那如何处理的呢？<br>通过 对象名.属性名 的方式获取属性值得时候，首先在对象私有的属性上进行查找，如果私有中存字这个属性，择获取的是私有属性；<br>如果私有的没有，择通过——proto——找到所属类的原型（类的原型上定义的属性和方法都是当前实例公有的属性和方法），原型上存在的话获取的是公有的属性值，如果原型上也没有的话则通过<em>proto</em>继续向上查找，一直找到基类（Object）的原型（prototype）上为止；<br>这种查找的机制就是我们的原型链模式；</p>
<p>#####链试写法<br>执行完数组的一个方法可以紧接着执行下一个方法；</p>
<p>#####原型扩展之批量设置公有属性<br>如何批量设置公有属性：<br>1.别名法如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> var  sts=Fn.prototype：</div><div class="line"> Fn.prototype.sum=function()&#123;&#125;</div><div class="line"> 同等于</div><div class="line"> sts.sum=function()&#123;&#125;</div><div class="line"> sts.a=fucntion()&#123;&#125;</div><div class="line"> sts..........</div><div class="line"> 这样只是少写代码</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>2.重构原型对象的方法<br>自己手动添加一个堆内存（公有的），但是只有浏览器天生给Fn.prototype开辟的堆内存里面才有constructor，而我们自己开辟的这个堆内存内没有这个属性，这样constructor指向就不是Fn了而是Object了；<br>为了和原来的保持一致，我们需要手动增加constructor的指向（constructor：Fn）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; function Fn()&#123;</div><div class="line">&gt; this.a=2</div><div class="line">&gt; &#125;</div><div class="line">&gt; 设置Fn的公有属性给他添加一个堆内存</div><div class="line">&gt; Fn.prototype= &#123;</div><div class="line">&gt; constructor：Fn//这样就指向Fn了</div><div class="line">&gt;   a：function ()&#123;&#125;</div><div class="line">&gt;   b:function()&#123;&#125;</div><div class="line">&gt;   c:function()&#123;&#125;</div><div class="line">&gt;   引用数据类型都会开辟一个新内存</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>3.用这种方法给内置类增加公有的属性比如给Array增加去重的方法，Array内置有很多方法比如sort，splice等等就被新开辟的堆内存覆盖掉，所以我们用这种方法会背浏览器屏蔽掉；<br>但是我们可以一个个的修改内置方法，当我们通过下述方法在数组的原型上增加方法，如果方法名和原来的内置重复了，会把人家的修改掉–&gt;我们以后再内置类的原型上增加方法，命名都要加特殊前缀；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array.prototype.sort=function()&#123;</div><div class="line">方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#####Object.create(obj1)</p>
<blockquote>
<p>Object.create（ProObj）创建一个新的对象，但是还要把proObj作为这个对象的原型</p>
<p>#####数据类型检测；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">constructor</div><div class="line">console.log(ary.constructor.name)</div><div class="line">console.log(ary.constructor)</div></pre></td></tr></table></figure></p>
<p>instanceof :检测这个实例是否属于某个类，能详细检测引用数据类型<br>对于基本数据类型，用字面量创建方式检测不出来，用构造函数创建的可以检测，因为每一种数据类型都对应自己所属的类，比如一个数字是Number类的实例，所以instanceof可以用来检测数据类型；<br>注意</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/02/js笔记/js正式课第二天/" data-id="cj27dljb00003lkvcjww1yxc5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-服务器使用方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/服务器使用方法/" class="article-date">
  <time datetime="2017-04-26T00:56:41.094Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#服务器使用方法</p>
<p>##window</p>
<ul>
<li><p>访问<a href="https://filezilla-project.org/下载传输工具（FTP）" target="_blank" rel="external">https://filezilla-project.org/下载传输工具（FTP）</a><br><img src="./1489823290422.png" alt="Alt text"></p>
</li>
<li><p>在window下安装FileZilla非常简单，双击安装程序，一路“next”即可完成安装，并在桌面创建 快键按钮。</p>
</li>
<li></li>
<li>输入<ul>
<li>【主机】123.57.223.74</li>
<li>【用户名】stu+qq</li>
<li>【密码】zfpx</li>
</ul>
</li>
</ul>
<p><img src="./1489805099679.png" alt="Alt text"><br><img src="./1489805135185.png" alt="Alt text"></p>
<ul>
<li>访问自己的网站<br><a href="http://work.zhufengpeixun.cn/stu8888/项目名/index.html" target="_blank" rel="external">http://work.zhufengpeixun.cn/stu8888/项目名/index.html</a></li>
</ul>
<p><a href="http://work.zhufengpeixun.cn/stu1519414263/华为导航/index.html" target="_blank" rel="external">http://work.zhufengpeixun.cn/stu1519414263/华为导航/index.html</a></p>
<p>最终效果<br><img src="./1489805285267.png" alt="Alt text"></p>
<p>##Mac</p>
<ul>
<li>下载安装包 同window</li>
<li>直接解压双击，即可使用</li>
<li>操作步骤与window相同</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/26/服务器使用方法/" data-id="cj1y9ullu00008kvcmoqay82r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第六天笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/第六天笔记/" class="article-date">
  <time datetime="2017-04-26T00:56:41.056Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#第六天笔记</p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="css的引入方式"><a href="#css的引入方式" class="headerlink" title="css的引入方式"></a>css的引入方式</h3><ul>
<li>行内式  将css属性通过style这个标签属性直接写在标签中（开始标签中）</li>
<li>内嵌式 将css属性写在style元素内，一般放在head元素内</li>
<li>外联式 将css属性写在css文件中，通过link元素将css文件引入到html中，一般这个元素写在head元素内</li>
<li>导入式 将css属性写在css文件中，通过@import url(“”)/@import ‘url’ 语句将css文件引入到html文件中<ul>
<li>@import 必须写在style元素内或者css文件内</li>
<li>@import 必须写在所在文件的第一行</li>
</ul>
</li>
</ul>
<h3 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h3><p>语法：选择器{声明;声明;}  每一个声明后面必须跟着分号</p>
<ul>
<li>标签选择器 权重 1 直接将标签名当做选择器 </li>
<li>类选择器 权重 10 将标签属性class的属性值当做选择器，选择器前面要加一个点 “.”     例如： .box{}</li>
<li>id选择器 权重 100 将标签属性id的属性值当做选择器，选择器前面要加一个井号 “#” </li>
<li>通配符选择器 *{}  选择当前文档下的所有元素  权重 0 &lt; x &lt; 1</li>
<li><p>分组选择器 权重 分开计算  将不同的选择器用逗号隔开，将同样的css属性一起给到不同的html元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div,p,span&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>交集选择器 权重 所有选择器之和 两个选择器紧挨在一起 </p>
<ul>
<li>标签选择器和其他选择器组合的时候，标签选择器要在前面  div.className{}    .className1.className2{}</li>
<li>组成这个选择器的两个属性或标签必须是同一个html元素的属性</li>
</ul>
</li>
<li><p>后代选择器 权重 所有选择器之和    父代空格子代{}</p>
<ul>
<li>父代和子代 不一定是相邻的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">div p span&#123;&#125;</div><div class="line">p span&#123;&#125;</div><div class="line">a span&#123;&#125;</div><div class="line">div span&#123;&#125;</div><div class="line">&lt;div&gt;</div><div class="line">	&lt;p&gt;</div><div class="line">		&lt;a&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt;</div><div class="line">	&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>子级选择器 权重 所有选择器权重之和  父级选择器&gt;子级选择器{} </p>
<ul>
<li>两个选择器是相邻的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">a&gt;span&#123;color:red;&#125;</div><div class="line">p&gt;a&gt;span&#123;&#125;</div><div class="line">div a&gt;span&#123;&#125;</div><div class="line">p a&gt;span&#123;&#125;</div><div class="line">p&gt;a span&#123;&#125;</div><div class="line">&lt;div&gt;</div><div class="line">	&lt;p&gt;</div><div class="line">		&lt;a&gt;aaaa&lt;span&gt;1111&lt;/span&gt;&lt;/a&gt;</div><div class="line">	&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>相邻兄弟选择器 权重 所有选择器之和 哥哥选择器+相邻弟弟选择器{}</p>
<ul>
<li>只能选择第一个弟弟元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">p+p&#123;color:red;&#125;  第二个和第三个都会被选择</div><div class="line">&lt;div&gt;</div><div class="line">	&lt;p&gt;</div><div class="line">		&lt;a&gt;aaaa&lt;span&gt;1111&lt;/span&gt;&lt;/a&gt;</div><div class="line">	&lt;/p&gt;</div><div class="line">	&lt;p&gt;</div><div class="line">		&lt;a&gt;aaaa&lt;span&gt;1111&lt;/span&gt;&lt;/a&gt;</div><div class="line">	&lt;/p&gt;</div><div class="line">	&lt;p&gt;</div><div class="line">		&lt;a&gt;aaaa&lt;span&gt;1111&lt;/span&gt;&lt;/a&gt;</div><div class="line">	&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>属性选择器 权重 10  将元素的标签属性名和属性值当做选择器，必须写在[]中</p>
<ul>
<li>[属性名]{}</li>
<li>[属性名=属性值]{}</li>
</ul>
</li>
<li>伪类  权重 10 指元素的一个状态 鼠标经过 点击… 基本选择器:伪类{}  .box:hover{}</li>
<li>伪元素  before  after  基本选择:伪元素{}器:before{display:;content:””;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">div:before&#123;display:block;content:&quot;before;&quot;&#125;</div><div class="line">div:after&#123;display:block;content:&quot;after;&quot;&#125;</div><div class="line"></div><div class="line">&lt;div&gt;</div><div class="line">	&lt;before&gt;我永远挨着div的开始标签&lt;/before&gt;</div><div class="line">	我是一个快乐的div</div><div class="line">	&lt;after&gt;我永远挨着div的结束标签&lt;/after&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><h4 id="block-块级元素"><a href="#block-块级元素" class="headerlink" title="block  块级元素"></a>block  块级元素</h4><p>遵循的浏览器渲染模式 BFC</p>
<ul>
<li>独占一行</li>
<li>子级元素默认会在父级元素的左上角，平级元素会向下排布</li>
<li>在不设置值宽高，宽度是父级元素内容的宽度，高度是本身内容的高度</li>
<li>可以直接设置盒子模型的所有属性</li>
<li>可以嵌套所有的元素<ul>
<li>p  dt  h1-h6 不能嵌套其他的块级元素<h4 id="inline-行内元素"><a href="#inline-行内元素" class="headerlink" title="inline  行内元素"></a>inline  行内元素</h4>遵循的浏览器渲染模式 IFC</li>
</ul>
</li>
<li>都会在一行显示，从左到右，到达父级盒子最大宽度后自动折行</li>
<li>宽高不能设置，宽度和高度是由本身内容撑起来的</li>
<li>可以设置border，padding的左右值和margin的左右值</li>
<li>行内元素不能嵌套块级元素 <ul>
<li>a元素必要的时候，可以嵌套其他块级元素（整个模块添加超链接的时候，才可以这样用）</li>
</ul>
</li>
<li>会受到内容长度的影响，出现基线对齐（上下对齐/垂直对齐） 将对齐方式改变为 盒子顶部对齐</li>
<li>在编辑代码的时候，元素之间有空格或回车的时候，在页面显示时，两个盒子之间有间隙<h4 id="inline-block-行内块级元素"><a href="#inline-block-行内块级元素" class="headerlink" title="inline-block  行内块级元素"></a>inline-block  行内块级元素</h4></li>
<li>都会在一行显示，从左到右，到达父级盒子最大宽度后自动折行</li>
<li>不设置宽高的时候，宽高由内容绝对，</li>
<li>直接设置宽度和高度，margin和padding</li>
<li>会受到内容长度的影响，出现基线对齐（上下对齐/垂直对齐） 将对齐方式改变为 盒子顶部对齐</li>
<li>在编辑代码的时候，元素之间有空格或回车的时候，在页面显示时，两个盒子之间有间隙</li>
</ul>
<p>总结：<br>常用的块级有哪些？<br>div ul ol li p h1-h6 dl dt dd table tr thead tbody tfoot form<br>常用的行内有哪些？<br>span a em i b strong u sup sub img（可以直接设置宽度高度）</p>
<h2 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 float"></a>浮动 float</h2><ul>
<li>left 左浮动  从第一个元素开始，在父级元素内，从左向右排列，到达父级元素的最大宽度时，会自动折行</li>
<li>right 右浮动 从第一个元素开始，在父级元素内，从右向左排列，到达父级元素的最大宽度时，会自动折行</li>
<li>none 去除浮动 将浮动元素的浮动属性去掉</li>
</ul>
<p>文档流：行内元素和块级元素默认的渲染模式</p>
<p>特点：</p>
<ul>
<li>脱离文档流（父级元素找不到子级元素）相当于来到了第二层级，平行于基本的文档流</li>
<li>所有元素都可以设置这个属性 a img div li ul… </li>
<li>浮动元素可以直接设置盒子模型的所有属性</li>
<li>浮动元素不设置宽高时，宽高是本身内容的大小</li>
<li>行内元素，行内块级元素和文字会围绕着浮动元素排列</li>
</ul>
<blockquote>
<p>有浮动属性的元素，排列方式听浮动的，没有浮动属性的元素，听display的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">	display:inline-block;</div><div class="line">	float:right; 浮动生效</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><h4 id="给父级元素设置高度"><a href="#给父级元素设置高度" class="headerlink" title="给父级元素设置高度"></a>给父级元素设置高度</h4><p>这个元素内是否有内容，高度都一定</p>
<h4 id="给父级元素设置overflow-hidden-属性"><a href="#给父级元素设置overflow-hidden-属性" class="headerlink" title="给父级元素设置overflow:hidden;属性"></a>给父级元素设置overflow:hidden;属性</h4><p>是将浮动的元素拉回文档流</p>
<h4 id="给父级元素设置float属性（父子元素都是浮动元素，就可以互相识别了）–-不要用"><a href="#给父级元素设置float属性（父子元素都是浮动元素，就可以互相识别了）–-不要用" class="headerlink" title="给父级元素设置float属性（父子元素都是浮动元素，就可以互相识别了）– 不要用"></a>给父级元素设置float属性（父子元素都是浮动元素，就可以互相识别了）– 不要用</h4><h4 id="利用clear-both-属性清除浮动"><a href="#利用clear-both-属性清除浮动" class="headerlink" title="利用clear:both;属性清除浮动"></a>利用clear:both;属性清除浮动</h4><ul>
<li>带有这个属性的元素必须是块级元素</li>
<li>带有这个属性的元素必须放在最后一个浮动元素之后</li>
<li>带有这个属性的元素不能带有float属性<br>利用伪类清除浮动是<strong>工作中最长用的方法</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">.clear&#123;*zoom:1;&#125;/*兼容低版本浏览器*/</div><div class="line">.clear:after&#123;display:block;content:&quot;&quot;;clear:both;&#125;/*兼容高版本浏览器*/</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;ul class=&quot;clear&quot;&gt;</div><div class="line">	&lt;li&gt;&lt;/li&gt;</div><div class="line">	&lt;li&gt;&lt;/li&gt;</div><div class="line">	&lt;li&gt;&lt;/li&gt;</div><div class="line">	&lt;!--::after--&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">```		</div><div class="line">## 定位</div><div class="line">### 相对定位</div><div class="line">特点：</div><div class="line">- 不脱离文档流</div><div class="line">- 参照物是本身</div><div class="line">- 给绝对定位的元素做参照物</div><div class="line">- 发生位置改变的时候，原来的位置还占用</div><div class="line">- 层级大于文档流内其他元素（会盖在其他元素之上）</div><div class="line">- 当top和bottom同时设定时，top生效；left和right同时设定时，left生效</div><div class="line">- position: relative;和float同时设定时，都生效，先浮动后定位（先脱离文档流）</div><div class="line"></div><div class="line">&gt; 盒子自己发生位置改变，又不影响其他元素的时候，选择用相对定位</div><div class="line"></div><div class="line">### 绝对定位</div><div class="line">- 脱离文档流</div><div class="line">- 所有元素默认都会去找参照物的起点位置，互相叠盖在一起</div><div class="line">- 宽高不设置时，宽度和高度是由本身内容决定的</div><div class="line">- 绝对定位的元素，如果不设置四个方向的值，并且同级之前有其他内容，它会默认排在这个内容之后</div><div class="line">- 当绝对定位元素有宽高的时候，top和bottom同时设置，top生效，left和right设置时，left生效</div><div class="line">- 绝对定位元素设置宽高100%时，继承的宽高是其参照物的宽高</div><div class="line">- 当绝对定位元素没有宽高的时候，</div><div class="line">- 在不设置参照物时，参照物是body（画布）</div><div class="line">- 可以认为设置参照物</div><div class="line">	- 需是这个绝对定位元素的父级（可不是紧邻的父级）元素</div><div class="line">	- 参照物元素必须是带有定位属性的元素（可以是相对、绝对、固定）</div><div class="line">	- 父级元素都有定位属性，绝对定位元素的参照物是离他最近的那个父级元素</div><div class="line">	- 平级元素不能作为参照物</div></pre></td></tr></table></figure>
</li>
</ul>
<p><div style="position: relative;"><br>    <p style="position: absolute;"><br>        <span style="position: absolute;"></span><br>    </p><br></div><br>```</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><ul>
<li>脱离文档流</li>
<li>参照物始终是可视窗口</li>
<li>不设置宽高时，宽度和高度是内容大小</li>
<li>多用在辅导航、返回头部等位置</li>
</ul>
<blockquote>
<p><code>&lt;a href=&quot;#top&quot;&gt;TOP&lt;/a&gt;</code><br>href 中 写一个# 或者 什么都不写 或者 写#top都可以实现返回头部的效果</p>
</blockquote>
<h3 id="去掉定位属性-position-static"><a href="#去掉定位属性-position-static" class="headerlink" title="去掉定位属性  position: static;"></a>去掉定位属性  position: static;</h3><h3 id="z-index-改变定位元素的层级关系"><a href="#z-index-改变定位元素的层级关系" class="headerlink" title="z-index 改变定位元素的层级关系"></a>z-index 改变定位元素的层级关系</h3><ul>
<li>不能改变父子之间的层级关系（正值）</li>
<li>可以设置负值，跑到所有元素之后</li>
<li>当父子元素都有z-index值的时候，如果父级元素之间有值，那么子级元素不会出来进行比较</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/26/第六天笔记/" data-id="cj1y9ulma00028kvcuh0zxvh4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第七天笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/第七天笔记/" class="article-date">
  <time datetime="2017-04-26T00:56:41.056Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#第七天笔记</p>
<h2 id="css的命名规范-（类名-id名）"><a href="#css的命名规范-（类名-id名）" class="headerlink" title="css的命名规范 （类名/id名）"></a>css的命名规范 （类名/id名）</h2><ul>
<li>不能是数字，也不能以数字为开头</li>
<li>严格区分大小写</li>
<li>遵循行业内的规范，例如 nav导航 subnav辅导航 banner 广告位  list 列表…</li>
<li>可以使用拼音全拼 miaosha</li>
<li>多个单词组成中间可以使用_ -进行连接  playbox play-box  play_box<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">常用的CSS命名规则</div><div class="line">头：header </div><div class="line">内容：content/container </div><div class="line">尾：footer </div><div class="line">导航：nav </div><div class="line">侧栏：sidebar </div><div class="line">栏目：column</div><div class="line">页面外围控制整体佈局宽度：wrapper </div><div class="line">左右中：left right center </div><div class="line">登录条：loginbar </div><div class="line">标志：logo </div><div class="line">广告：banner </div><div class="line">页面主体：main </div><div class="line">热点：hot </div><div class="line">新闻：news </div><div class="line">下载：download </div><div class="line">子导航：subnav </div><div class="line">菜单：menu </div><div class="line">子菜单：submenu </div><div class="line">搜索：search </div><div class="line">友情链接：friendlink / link</div><div class="line">页脚：footer </div><div class="line">版权：copyright </div><div class="line">滚动：scroll </div><div class="line">内容：content </div><div class="line">标签：tags </div><div class="line">文章列表：list </div><div class="line">提示信息：msg </div><div class="line">小技巧：tips </div><div class="line">栏目标题：title </div><div class="line">加入：joinus </div><div class="line">指南：guide </div><div class="line">服务：service </div><div class="line">注册：regsiter </div><div class="line">状态：status </div><div class="line">投票：vote </div><div class="line">合作伙伴：partner</div><div class="line">注释的写法:</div><div class="line">/* Header */ </div><div class="line">内容区 </div><div class="line">/* End Header */</div><div class="line">id的命名:</div><div class="line">1)页面结构</div><div class="line">容器: container </div><div class="line">页头：header </div><div class="line">内容：content/container </div><div class="line">页面主体：main </div><div class="line">页尾：footer </div><div class="line">导航：nav </div><div class="line">侧栏：sidebar </div><div class="line">栏目：column </div><div class="line">页面外围控制整体佈局宽度：wrapper </div><div class="line">左右中：left right center</div><div class="line">(2)导航</div><div class="line">导航：nav </div><div class="line">主导航：mainnav </div><div class="line">子导航：subnav </div><div class="line">顶导航：topnav </div><div class="line">边导航：sidebar </div><div class="line">左导航：leftsidebar </div><div class="line">右导航：rightsidebar </div><div class="line">菜单：menu </div><div class="line">子菜单：submenu </div><div class="line">标题: title </div><div class="line">摘要: summary</div><div class="line">(3)功能</div><div class="line">标志：logo </div><div class="line">广告：banner </div><div class="line">登陆：login </div><div class="line">登录条：loginbar </div><div class="line">注册：register </div><div class="line">搜索：search </div><div class="line">功能区：shop </div><div class="line">标题：title </div><div class="line">加入：joinus </div><div class="line">状态：status </div><div class="line">按钮：btn </div><div class="line">滚动：scroll </div><div class="line">标籤页：tab </div><div class="line">文章列表：list </div><div class="line">提示信息：msg </div><div class="line">当前的: current </div><div class="line">小技巧：tips </div><div class="line">图标: icon </div><div class="line">注释：note </div><div class="line">指南：guild </div><div class="line">服务：service </div><div class="line">热点：hot </div><div class="line">新闻：news </div><div class="line">下载：download </div><div class="line">投票：vote </div><div class="line">合作伙伴：partner </div><div class="line">友情链接：link </div><div class="line">版权：copyright</div><div class="line">四、注意事项:</div><div class="line">1.一律小写; </div><div class="line">2.尽量用英文; </div><div class="line">4.尽量不缩写，除非一看就明白的单词。</div><div class="line">rmb renminbi</div><div class="line">五、CSS样式表文件命名</div><div class="line">主要的 master.css </div><div class="line">模块 module.css </div><div class="line">基本共用 base.css </div><div class="line">布局、版面 layout.css </div><div class="line">主题 themes.css </div><div class="line">专栏 columns.css </div><div class="line">文字 font.css </div><div class="line">表单 forms.css </div><div class="line">补丁 mend.css </div><div class="line">打印 print.css</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><h3 id="length（长度）"><a href="#length（长度）" class="headerlink" title="length（长度）"></a>length（长度）</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>px（像素）</td>
<td>相对单位，分辨率</td>
</tr>
<tr>
<td>em 倍数</td>
<td>是本身字体或父级字体大小的倍数</td>
</tr>
<tr>
<td>rem 倍数</td>
<td>是html根元素字体大小的倍数</td>
</tr>
<tr>
<td>百分数</td>
<td>是父级元素宽度或者高度的百分之多少，如果是绝对定位的元素，是参照物的百分之多少</td>
</tr>
</tbody>
</table>
<h3 id="色值（颜色）"><a href="#色值（颜色）" class="headerlink" title="色值（颜色）"></a>色值（颜色）</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>英文单词</td>
<td>red pink… 不常用</td>
</tr>
<tr>
<td>十六进制</td>
<td>#00ffff #0ff #000fff（这种不能缩写）</td>
</tr>
<tr>
<td>rgb(0,0,0)</td>
<td>红 绿 蓝</td>
</tr>
<tr>
<td>rgba(0,0,0,0.5)</td>
<td>红 绿 蓝 透明度（不兼容ie低版本）</td>
</tr>
<tr>
<td>cmyk</td>
<td>印刷颜色 不用 （有时候存储图片的格式存储成了cmyk 在ie低版本浏览器中图片是不显示的）</td>
</tr>
</tbody>
</table>
<p><img src="./1490668221909.png" alt="Alt text"><br>调整模式后再保存一份<br><img src="./1490668315290.png" alt="Alt text"></p>
<blockquote>
<p>有宽度或者高度的定位元素，同时设置top和bottom时，top生效，可以将top值重新设置为auto，那么top就会恢复到初始状态，bottom值就会生效，left和right同上<br>大部分css属性设置为auto都是默认状态（初始值）<br><img src="./1490669464197.png" alt="Alt text"></p>
</blockquote>
<h2 id="opacity-透明度"><a href="#opacity-透明度" class="headerlink" title="opacity 透明度"></a>opacity 透明度</h2><p>opacity:0.3; 兼容高版本浏览器<br>filter:alpha(opacity=30);兼容ie低版本浏览器</p>
<blockquote>
<p>有这个属性的元素，里面所有内容都会变成半透明</p>
</blockquote>
<h2 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h2><ul>
<li>这个属性用在有宽度的元素身上</li>
<li>有这个属性的子级元素，如果属性为inline，inline-block或者是文字，都可以受到这个属性的影响</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><ul>
<li>给绝对定位做参照物</li>
<li>自己进行移动</li>
</ul>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>指定一个元素在另一个元素内的某个位置</p>
<blockquote>
<p>写在css文件中的内容是间接引入到html文件中，浏览器在加载的时候，写在css中的图片是不能够被html直接调用的，后台或者前台编辑人员是不能够通过一定手段改变图片的，所以在页面上经常更换的图片，需要用img标签引入</p>
<p>alt+delete ps中是添加背景颜色</p>
<p>在项目中 公共文件会放在自己写的文件之前，因为那个文件要先加载</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/26/第七天笔记/" data-id="cj1y9ullu00018kvcy129cvri" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css选择器2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/css选择器2/" class="article-date">
  <time datetime="2017-04-26T00:56:41.025Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CSS3-选择器"><a href="#CSS3-选择器" class="headerlink" title="CSS3 选择器"></a>CSS3 选择器</h1><p><img src="./1491215920229.png" alt="Alt text"></p>
<h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>类型</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>通配符</td>
<td>选择所有的HTML元素</td>
</tr>
<tr>
<td>Element</td>
<td>元素选择器</td>
<td>选择指定HTML元素</td>
</tr>
<tr>
<td>#id</td>
<td>id选择器</td>
<td>选择指定ID属性值为“id”的任意类型元素</td>
</tr>
<tr>
<td>.class</td>
<td>类选择器</td>
<td>选择指定class属性值为“class”的任意类型的任意多个元素</td>
</tr>
<tr>
<td>selector1,selectorN</td>
<td>分组选择器</td>
<td>将每一个选择器匹配的元素集合并</td>
</tr>
</tbody>
</table>
<h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>类型</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>E F</td>
<td>后代选择器（包含选择器）</td>
<td>选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内</td>
</tr>
<tr>
<td>E &gt; F</td>
<td>子选择器</td>
<td>选择元素E下面的第一层级F元素</td>
</tr>
<tr>
<td>E + F</td>
<td>相邻兄弟选择器</td>
<td>选择E元素平级并且相邻的F元素</td>
</tr>
<tr>
<td>E ~ F</td>
<td>通用选择器</td>
<td>选择前面有 E 元素的每个 F 元素</td>
</tr>
</tbody>
</table>
<h2 id="动态伪类选择器"><a href="#动态伪类选择器" class="headerlink" title="动态伪类选择器"></a>动态伪类选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Element:link</td>
<td>链接伪类选择器</td>
<td>未访问状态</td>
</tr>
<tr>
<td>Element:visited</td>
<td>链接伪类选择器</td>
<td>访问后状态</td>
</tr>
<tr>
<td>Element:active</td>
<td>用户行为选择器</td>
<td>被激活，常用链接与按钮</td>
</tr>
<tr>
<td>Element:hover</td>
<td>用户行为选择器</td>
<td>鼠标停留</td>
</tr>
<tr>
<td>Element:focus</td>
<td>用户行为选择器</td>
<td>获取焦点</td>
</tr>
</tbody>
</table>
<h2 id="目标伪类选择器"><a href="#目标伪类选择器" class="headerlink" title="目标伪类选择器"></a>目标伪类选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:target</td>
<td>选择匹配E的所有元素，且匹配元素被相关URL指向</td>
</tr>
</tbody>
</table>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[attribute]</td>
<td>选择带有相同标签属性所有元素</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>选择相同标签属性和属性值的所有元素</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>选择属性包含指定名字的所有元素</td>
</tr>
<tr>
<td>[attribute</td>
<td>=value]</td>
<td>选择指定属性名的属性值以指定字母开头的所有元素</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>选择其 src 属性值以 “https” 开头的每个 <code>&lt;a&gt;</code> 元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>选择其 src 属性以 “.pdf” 结尾的所有 <code>&lt;a&gt;</code> 元素</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>选择其 src 属性中包含 “abc” 子串的每个 <code>&lt;a&gt;</code>元素</td>
</tr>
</tbody>
</table>
<h2 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:first-of-type</td>
<td>选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code>元素</td>
</tr>
<tr>
<td>nth-child(n)</td>
<td>选择属于其父元素的第n个指定子元素，Odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词，使用公式 (an + b)</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>同上，从最后一个元素计数</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>选择属于其父元素第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素,也可使用Odd和even与公式（an+b）</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>同上，从最后一个元素计数</td>
</tr>
<tr>
<td>:last-child</td>
<td>选择属于其父元素最后一个子元素</td>
</tr>
<tr>
<td>:root</td>
<td>选择跟元素（html）</td>
</tr>
<tr>
<td>:empty</td>
<td>选择没有子元素的元素</td>
</tr>
<tr>
<td>:enabled</td>
<td>已经使用的input元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>选择禁用的input元素</td>
</tr>
<tr>
<td>:checked</td>
<td>被选中的input元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>选择非p元素</td>
</tr>
<tr>
<td>::selection</td>
<td>选择用户选择部分</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>名称</th>
<th>举例</th>
<th>描述</th>
<th>ie(6-8)</th>
<th>ie(9+)</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>×</td>
<td>√</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/26/css选择器2/" data-id="cj1y9ulma00038kvcm8zwg0rr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第四天笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/25/第四天笔记/" class="article-date">
  <time datetime="2017-04-25T11:00:29.364Z" itemprop="datePublished">2017-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第四天笔记"><a href="#第四天笔记" class="headerlink" title="第四天笔记"></a>第四天笔记</h1><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><blockquote>
<p>选择器的组成不要超过三个<br>选择器的查找机制是从右向左  <strong>面试题</strong><br>后代选择器没有必要将每一层元素都写出来，只写那些关键节点即可（具有代表性的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.div1 ul li&#123;&#125;</div><div class="line">第一步选择这个文档下所有的li</div><div class="line">第二步选择哪些li是ul下面的</div><div class="line">第三步选择哪些li是ul下面，ul还是.div1下面的</div></pre></td></tr></table></figure></p>
</blockquote>
<p>交集选择器<br>一个元素具有两个属性，可以将这两个属性做成交集选择器<br>组成选择器的两部分，必须属于同一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h1.p1&#123;&#125;  -- &gt;  什么都选择不到</div><div class="line">p.p1&#123;&#125;   p.p2&#123;&#125;  .p1.p2&#123;&#125; p.p3&#123;&#125;</div><div class="line">&lt;p class=&quot;p1 p2 p3&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;h1&gt;&lt;/h1&gt;</div></pre></td></tr></table></figure></p>
<p>后代选择器（派生选择器）<br>祖籍 子级{}  只要存在后代关系即可</p>
<p>子级选择器<br>父级&gt;子级{}  父子两个元素是相邻</p>
<p>属性选择器<br>只要是标签属性都可以用属性选择器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[href]&#123;&#125;</div><div class="line">[href=url]&#123;&#125;</div><div class="line">[title]&#123;&#125;</div><div class="line">[title=zfpx]&#123;&#125;</div><div class="line">.title&#123;&#125;</div><div class="line">[class]&#123;&#125;</div><div class="line">[class=title]&#123;&#125;</div><div class="line">&lt;a href=&quot;url&quot; title=&apos;zfpx&apos; class=&apos;title&apos;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>根据这个属性可以将元素分成不同的类型，也会显示出不同的状态，例如属性值为block的时候，这个元素会独占一行，如果属性值为inline的时候，所由这个属性值的元素都会在一行显示.，属性值为none，元素会在页面上消失…</p>
<p>所有元素都有天生自带的display属性和属性值，叫做内置属性</p>
<h4 id="block-块状元素（块级元素）"><a href="#block-块状元素（块级元素）" class="headerlink" title="block   块状元素（块级元素）"></a>block   块状元素（块级元素）</h4><p>特点：</p>
<ul>
<li>独占一行</li>
<li>可以设置盒子模型的所有属性（width、height、border、padding、margin）</li>
<li>默认宽度是父级元素内容的宽度，高度是本身内容的高度</li>
<li>可以嵌套其他元素<ul>
<li>dt 不能嵌套其他块级，可以嵌套行内元素等</li>
<li>p不能嵌套块级元素，可以嵌套行内元素等</li>
</ul>
</li>
<li>永远会在父级盒子的左上角开始排布，从上到下排</li>
</ul>
<blockquote>
<p>人为设置的样式要比元素自带的样式权重高<br>块级元素这些特点，我们将其称作 BFC（block formatting context）块状元素在上下文中的渲染模式（块状元素应该怎么排布）  <strong>面试题</strong></p>
</blockquote>
<h4 id="inline-行内元素（内联元素）"><a href="#inline-行内元素（内联元素）" class="headerlink" title="inline 行内元素（内联元素）"></a>inline 行内元素（内联元素）</h4><p>特点：</p>
<ul>
<li>在一行显示</li>
<li>不能设置宽度、高度</li>
<li>padding、margin的上下值设置不生效，左右值生效</li>
<li>默认宽度高度是本身内容的宽高</li>
<li>几个行内元素默认的垂直方向对齐方式是基线对齐</li>
<li>在编辑代码时，如果行内元素之间有回车或者空格，那么在页面显示的时候，就会默认有间隙<ul>
<li>将font-size设置为0，可以解决这个问题</li>
</ul>
</li>
<li>行内元素不能嵌套块级元素</li>
</ul>
<h4 id="inline-block-行内块级元素"><a href="#inline-block-行内块级元素" class="headerlink" title="inline-block 行内块级元素"></a>inline-block 行内块级元素</h4><p>特点：</p>
<ul>
<li>在一行显示</li>
<li>可以直接设置宽度高度padding margin值</li>
<li>默认宽度高度是本身内容的宽高</li>
<li>几个行内元素默认的垂直方向对齐方式是基线对齐</li>
<li>在编辑代码时，如果行内元素之间有回车或者空格，那么在页面显示的时候，就会默认有间隙<ul>
<li>将font-size设置为0，可以解决这个问题</li>
</ul>
</li>
<li>行内元素不能嵌套块级元素</li>
</ul>
<h4 id="vertical-align-改变行内元素和行内块级元素的基线对齐方式"><a href="#vertical-align-改变行内元素和行内块级元素的基线对齐方式" class="headerlink" title="vertical-align 改变行内元素和行内块级元素的基线对齐方式"></a>vertical-align 改变行内元素和行内块级元素的基线对齐方式</h4><table>
<thead>
<tr>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>所有平级元素，去找最高（高度最高）元素的顶部进行对齐</td>
</tr>
<tr>
<td>bottom</td>
<td>所有平级元素，去找最高（高度最高）元素的底部进行对齐</td>
</tr>
<tr>
<td>middle</td>
<td>所有平级元素，去找最高（高度最高）元素的中部进行对齐</td>
</tr>
<tr>
<td>length（数值）</td>
<td>px %</td>
</tr>
</tbody>
</table>
<blockquote>
<p>改变对齐方式的时候，所有元素都要添加这个属性</p>
</blockquote>
<h4 id="none-将这个元素在页面上隐藏起来（完全消失）"><a href="#none-将这个元素在页面上隐藏起来（完全消失）" class="headerlink" title="none 将这个元素在页面上隐藏起来（完全消失）"></a>none 将这个元素在页面上隐藏起来（完全消失）</h4><blockquote>
<p>怎样再显示出来：将none用其他的属性值替换，一般使用block</p>
</blockquote>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>每一个元素在html中都是一个盒子，用来装其他盒子或者是内容</p>
<p>可以将html页面看做是一个仓库，仓库中从上到下摆了很多的箱子，易碎品 （盒子和盒子之间要有距离 内容与盒子之间要有填充  盒子本身要有厚度）</p>
<p>height: 100%; 指的是继承父级元素“内容”的高度<br>width:100%;指的是继承父级元素“内容”的宽度</p>
<blockquote>
<p>父子关系的时候，在设置margin值的时候，一般只设置上和左，不会设置下和右</p>
</blockquote>
<p>盒子自身的宽度=左侧边框的宽度+左侧内边距+内容宽度+右侧内边距+右侧边框的宽度<br>allWidth=(border-left-width) + (padding-left) + (width) + (padding-right) + (border-right-width)</p>
<p>allHeight=(border-top-width) + (padding-top) + (height) + (padding-bottom) + (border-bottom-width)</p>
<p>padding和margin<br>padding:1px 2px 3px 4px;<br>            top right bottom left<br>padding:1px 2px 3px;<br>            top   left/right   bottom<br>padding:1px 2px;   top/bottom  left/right</p>
<p>border的写法<br>border-top-width  上边框的宽度<br>border-top-style   上边框的样式<br>border-top-color   上边框的颜色</p>
<p>border-color : red green yellow pink; 上右下左<br>border-color:red green yellow; 上 左右 下<br>border-color:red green; 上下  左右<br>border-color:red; 四个方向是一个颜色</p>
<p>border-width : 1px 2px 3px 4px; 上右下左<br>border-color: 1px 2px 3px; 上 左右 下<br>border-color:1px 2px; 上下  左右<br>border-color:3px; 四个方向是一个颜色</p>
<p>border-top : 1px solid pink; </p>
<p>border:1px solid pink;  四个方向所有样式一致</p>
<h4 id="margin-支持负值"><a href="#margin-支持负值" class="headerlink" title="margin 支持负值"></a>margin 支持负值</h4><p>margin-left:-30px;</p>
<p>margin-left和margin-top为负值的时候 跑出浏览器的部分会被吃掉，不会撑开整个页面</p>
<h4 id="margin-top的传递问题"><a href="#margin-top的传递问题" class="headerlink" title="margin-top的传递问题"></a>margin-top的传递问题</h4><p>如果父级元素没有padding-top或border-top值的时候，子元素设置margin-top值，会将这个值传递给父元素</p>
<p>解决方法：</p>
<ul>
<li>给父级元素一个属性，overflow:hidden;</li>
<li>将子级元素的margin-top值去掉，改成父级元素的padding-top值  这个方法建议使用</li>
</ul>
<h4 id="margin-left-margin-right-在-ie6-中会双倍"><a href="#margin-left-margin-right-在-ie6-中会双倍" class="headerlink" title="margin-left/margin-right 在 ie6 中会双倍"></a>margin-left/margin-right 在 ie6 中会双倍</h4><p>当个元素浮动的时候，有左右的外边距，有时候ie6会出现双倍边距的问题<br>解决方案：</p>
<ul>
<li>给这个元素添加overflow:hidden;</li>
<li>写ie6的兼容方式 例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">	float:left;</div><div class="line">	margin-left:10px !important;</div><div class="line">	_margin-left:5px;/*当浏览器是ie6的时候，读取这句话*/  </div><div class="line">	CSS属性hack</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>!important  出现正在css里面的时候，这个属性会覆盖掉所有之前设置的样式  — 面试题</p>
<p><strong><a href="http://baike.baidu.com/item/css%20hack?fr=aladdin" target="_blank" rel="external">css hack</a></strong></p>
<h4 id="overflow-盒子内容多余部分的处理方式"><a href="#overflow-盒子内容多余部分的处理方式" class="headerlink" title="overflow 盒子内容多余部分的处理方式"></a>overflow 盒子内容多余部分的处理方式</h4><p>overflow:hidden; 直接将多余的隐藏<br>overflow:auto; 如果有多余部分出现滚动条，如果没有就不出现<br>overflow:scroll; 不论是否有多余部分，都会出现滚动条</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/25/第四天笔记/" data-id="cj1xfzk3y000b6kvcoc5x6mw1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第十五天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/25/第十五天/" class="article-date">
  <time datetime="2017-04-25T11:00:29.351Z" itemprop="datePublished">2017-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#第十五天</p>
<p>###h5兼容浏览器<br>IE9+ 谷歌 火狐 safafi 欧朋 </p>
<p>###H5标签的特点</p>
<ul>
<li>标签语义化</li>
<li>利用seo的引擎搜索</li>
<li>语法更宽松</li>
<li>多设备跨平台</li>
<li>自适应网页设计（适应响应式布局）</li>
</ul>
<h3 id="h5-新增标签"><a href="#h5-新增标签" class="headerlink" title="h5  新增标签"></a>h5  新增标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td>头部</td>
</tr>
<tr>
<td>nav</td>
<td>导航</td>
</tr>
<tr>
<td>article</td>
<td>文章(文章列表页)</td>
</tr>
<tr>
<td>aside</td>
<td>侧边导航(文章右侧)</td>
</tr>
<tr>
<td>footer</td>
<td>尾部</td>
</tr>
<tr>
<td>section</td>
<td>自定义章节</td>
</tr>
<tr>
<td>figure</td>
<td>配图</td>
</tr>
<tr>
<td>figcaption</td>
<td>配图的标题或者描述(一般是和figure一块用的)</td>
</tr>
<tr>
<td>video</td>
<td>视频</td>
</tr>
<tr>
<td>audio</td>
<td>音频</td>
</tr>
<tr>
<td>mark</td>
<td>提高高亮</td>
</tr>
<tr>
<td>canvas</td>
<td>画布(必须结合JS在实现其中本身的价值)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>canvas 在这个标签里面写内容，是不显示的<br>figcaption单独用是不可以的，必须是和figure一块用(或者说必须包在figure里面)<br>一般首页是index.html页面，从首页点击进去的一个页面是二级页面（文章列表页），从二级页面点击进去的是一个三级页面(文章页面)</p>
</blockquote>
<p>###怎么在IE6-8兼容H5标签？<br>在页面中引入一个html5.js 就可以了</p>
<h3 id="引入JS的方式"><a href="#引入JS的方式" class="headerlink" title="引入JS的方式"></a>引入JS的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">内嵌式</div><div class="line">&lt;script&gt;这里是JS代码&lt;/script&gt;</div><div class="line">外联式</div><div class="line">&lt;script src=&apos;引入JS的路径&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>##选择器</p>
<p>###属性选择器<br>E[attr~=”value”]<br>指定属性名，并且具有属性值，此属性值是一个词列表（类名），并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">div[class~=&quot;test&quot;]&#123;background:red;&#125;</div><div class="line">&lt;/style</div><div class="line">&lt;div class=&quot;frist-test&quot;&gt;这个是第一个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;box1&quot;&gt;第二个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test div1&quot;&gt;第三个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test_1 test test1&quot;&gt;第四个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;box box2 box31&quot;&gt;第五个&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>E[attr^=”value”]<br>指定属性名，并且具有属性值，^是以什么为开头的，value可以是首字母为开头或者以类名开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">div[class^=&quot;t&quot;]&#123;background:yellow;&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;div class=&quot;box1&quot;&gt;第二个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test div1&quot;&gt;第三个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test_1 test test1&quot;&gt;第四个div&lt;/div&gt;</div><div class="line">&lt;/style</div></pre></td></tr></table></figure></p>
<p>E[attr$=”value”]<br>指定属性名，并且具有属性值，$是以什么为结尾的，value可以是末尾字母为结尾或者类名结尾，有很多类名的情况下，是最后一个类名以什么结尾的才有效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">div[class$=&quot;t&quot;]&#123;background:yellow;&#125;</div><div class="line">&lt;/style</div><div class="line">&lt;div class=&quot;box1&quot;&gt;第二个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test div1&quot;&gt;第三个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test_1 test test1&quot;&gt;第四个div&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>E[attr<em>=”value”]<br>指定属性名，并且具有属性值，</em> 可以是任意一个字母或者整个单词<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">div[class*=&quot;test&quot;]&#123;</div><div class="line">	background: springgreen;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;div class=&quot;box1&quot;&gt;第二个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;div1 test&quot;&gt;第三个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test_1 test test1&quot;&gt;第四个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;box box2 box31&quot;&gt;第五个&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>E[attr|=”value”]<br>指定了属性名，并且属性值是value(在class中只有一个类名)或者以“value-”开头的值（比如说zh-cn）;只可以是以整个单词（只有一个属性值）或者单词-（可以多个属性值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">div[class|=&apos;zh&apos;]&#123;</div><div class="line">	background: chocolate;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;zh test div1&quot;&gt;第三个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;test-1 test1&quot;&gt;第四个div&lt;/div&gt;</div><div class="line">&lt;div class=&quot;zh-cn box box-1 &quot;&gt;第五个&lt;/div&gt;</div><div class="line">&lt;div class=&quot;zh&quot;&gt;dddd&lt;/div&gt;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>###伪类选择器<br>权重 20 &gt; 伪类选择器 &gt;11<br>:first-child 选择某一个元素的第一个子元素<br>:last-child 选择某一个元素的最后一个子元素<br>:nth-child(n) 选择某一个元素的第n个子元素，n不能为负数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">.dome p:nth-child(1)&#123;background:red;&#125;</div><div class="line">.dome p:frist-child&#123;background:yellow;&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;div class=&quot;dome&quot;&gt;</div><div class="line">    &lt;p&gt;1&lt;/p&gt;</div><div class="line">    &lt;p&gt;2&lt;/p&gt;</div><div class="line">    &lt;p&gt;3&lt;/p&gt;</div><div class="line">    &lt;p&gt;4&lt;/p&gt;</div><div class="line">    &lt;p&gt;5&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>伪类选择器它是针对列表或者很多同级的标签时用的，img下是没有效果的也用不到伪类选择器<br>伪类选择器后面加hover是可行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:nth-child(1):hover&#123;</div><div class="line">  background: darkblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>:nth-child(n*length) n的倍数。n默认是全部变成红色，2n是偶数变成黄色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:nth-child(3n)&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:nth-child(n+length) 选择大于length后面的元素  （包含length）length是从0开始的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:nth-child(n+2)&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:nth-child(-n+length) 选择小于等于length前面的元素（包含这个length）  length是从0开始的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:nth-child(-n+5)&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:nth-child(n*length+length) 表示隔几选几，这种方法是实现隔几选几的效果，比如我们这里是隔三选一–&gt;li:nth-child(3n+1){}，如果你把”4”换成别的数字那就是另外的一种隔法了，比如这个实例li:nth-child(4n+1) {background: lime;}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:nth-child(4n+4)&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:nth-last-child(length) 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> li:nth-last-child(3)&#123;</div><div class="line">	background: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:nth-of-type(length) 选择指定的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:nth-of-type(1)&#123;</div><div class="line">	border:10px red solid;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>nth-child()和nth-of-type()的区别：<br>因为它是以”type”来区分的。也就是说：li:nth-of-type(1){background:red;}是指父元素下第1个li元素，而li:nth-child(1){background:red;}是指父元素下第1个元素</p>
</blockquote>
<p>:nth-last-of-type(length) 在同级元素中，从最后开始找。选择指定的元素，从元素的最后一个开始计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> li:nth-last-of-type(3)&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:first-of-type 选择一个上级元素下的第一个同类子元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:first-of-type&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:last-of-type 选择一个上级元素下的最后一个同类子元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">li:last-of-type&#123;</div><div class="line">	background: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:only-child 在父元素中，里面子元素是唯一的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div p:only-child&#123;</div><div class="line">background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:only-of-type 在父元素中，里面很多个子元素，但是有一个子元素是唯一的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div p:only-of-type&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>:empty 选择的元素里面没有任何内容。</p>
<blockquote>
<p>  empty是用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格，比如说，你有三个段落，其中一个段落什么都没有，完全是空的你想这个p不显示，那你就可这样来写：p:empty {display: none;}</p>
</blockquote>
<p>:not  否定选择器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">input:not([type=&apos;submit&apos;])&#123;</div><div class="line">	border:1px solid blue;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;input type=&quot;text&quot;&gt;</div><div class="line">&lt;input type=&quot;button&quot;&gt;</div><div class="line">&lt;input type=&quot;submit&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>:root 根元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">:root&#123;</div><div class="line">	background: red;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;a href=&quot;#new&quot;&gt;我是个超链接&lt;/a&gt;</div><div class="line">&lt;p id=&quot;new&quot;&gt;sssssssssss&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>:target 选择器可用于选取当前活动的目标元素。</p>
<blockquote>
<p>使用该选择器来对页面中的某个target元素（该元素的id当做页面中的超链接来使用）指定样式，该样式只在用户点击了页面中的超链接，并且跳转到target元素后起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">        :target&#123;</div><div class="line">            border:1px solid red;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>###什么是浏览器私有属性前缀？<br>以下是几种常用前缀<br>-webkit- 谷歌 -moz- 火狐 -ms- IE浏览器 -o- 欧朋</p>
<p>####CSS3前缀+标准代码的顺序是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-webkit-border-radius: 50%;/*谷歌*/</div><div class="line">-o-border-radius:50%;/*欧朋*/</div><div class="line">-moz-border-radius: 50%;/*火狐*/</div><div class="line">-ms-border-radius:50%;/*IE9+*/</div><div class="line">border-radius: 50%;/*默认*/</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/25/第十五天/" data-id="cj1xfzk3l00086kvcdcfi4pdr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/02/js笔记/正式课第一天/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/02/js笔记/js正式课第三天(周六)/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/02/js笔记/js正式课第二周第一天/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/02/js笔记/js正式课第二天/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/04/26/服务器使用方法/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>